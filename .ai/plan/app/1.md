Excellent. This is a professional software engineering approach. Separating the analysis logic from the view and managing it through a layered context system is the perfect architecture for this problem. It makes the system modular, testable, and scalable.

Here is a detailed plan for the analysis engine, structured as you requested.

### **Core Principle: The Analysis Pipeline**

The core idea is a one-way data flow pipeline. A change in the circuit model triggers a cascade of updates through three specialized layers of context, each refining the data for the next step until it's ready for presentation.

**Raw Circuit Model (`Circuit`) -> [Context 1: Validation] -> Validated Graph (`AnalysisGraph`) -> [Context 2: Calculation] -> Solved Matrices (`CalculationResult`) -> [Context 3: Presentation] -> Formatted Output (`MarkdownString`) -> UI**

---

### **Directory Structure**

```
src/
|-- analysis/
|   |-- contexts/
|   |   |-- AnalysisProvider.tsx       // Layer 1: Validation
|   |   |-- MatrixCalculationProvider.tsx// Layer 2: Math
|   |   |-- PresentationProvider.tsx     // Layer 3: Formatting
|   |   |-- hooks.ts                   // Custom hooks (useAnalysis, useMatrixCalculations, etc.)
|   |
|   |-- utils/
|   |   |-- graphTransformer.ts        // Converts Circuit model to a pure graph model
|   |   |-- validation.ts              // Checks if a circuit is solvable
|   |   |-- nodalAnalysis.ts           // All math for the Nodal (Cut-set) method
|   |   |-- loopAnalysis.ts            // All math for the Loop (Tie-set) method
|   |   |-- reportGenerator.ts         // Converts calculation results to Markdown
|   |
|   |-- types.ts                       // TypeScript interfaces for the analysis pipeline
|
|-- components/
|   |-- AnalysisPane.tsx               // The main UI component for Pane 3
```

---

### **Step 1: Define the Data Structures (`analysis/types.ts`)**

These interfaces define the shape of the data as it flows through the pipeline.

```typescript
import { Matrix } from "mathjs";

// Input from the main app (Zustand store)
export interface Circuit {
  /* ... as defined previously ... */
}

// --- Output of Layer 1: A pure, analysis-ready graph model ---
export interface ElectricalNode {
  id: string; // e.g., 'n0', 'n1'
  connectedBranchIds: string[];
}

export interface Branch {
  id: string; // The original component ID, e.g., 'R1'
  type: "resistor" | "voltageSource" | "currentSource";
  value: number;
  // Defines the connection and direction
  fromNodeId: string;
  toNodeId: string;
}

export interface AnalysisGraph {
  nodes: ElectricalNode[];
  branches: Branch[];
  referenceNodeId: string;
  // For Loop Analysis
  spanningTreeBranchIds: string[];
  linkBranchIds: string[];
}

// --- Output of Layer 2: All calculated mathematical objects ---
export interface CalculationResult {
  // Input Matrices
  incidenceMatrix: Matrix; // (A)
  tieSetMatrix: Matrix; // (B)
  branchImpedanceMatrix: Matrix; // (ZB)
  branchAdmittanceMatrix: Matrix; // (YB)

  // Solution Vectors
  nodeVoltages: Matrix; // (Vn)
  loopCurrents: Matrix; // (IL)

  // Final Results
  branchVoltages: Matrix; // (VB)
  branchCurrents: Matrix; // (JB)
}

// --- Context State Shapes ---
export interface AnalysisState {
  analysisGraph: AnalysisGraph | null;
  isValid: boolean;
  isSolvable: boolean;
  error: string | null;
}

export interface MatrixCalculationState {
  result: CalculationResult | null;
  isCalculating: boolean;
  error: string | null;
}

export interface PresentationState {
  markdownOutput: string;
  isGenerating: boolean;
}
```

---

### **Step 2: Utility Functions (`analysis/utils/`)**

This is where the pure, non-React logic resides.

#### **`graphTransformer.ts`**

- **`createAnalysisGraph(circuit: Circuit): AnalysisGraph`**:
  - **Identifies Electrical Nodes:** Iterates through all `circuit.edges` and creates a unique `ElectricalNode` for each connection point. A simple approach is to create a map where keys are component IDs and values are node IDs.
  - **Creates Branches:** Maps `circuit.nodes` to the `Branch` interface, determining `fromNodeId` and `toNodeId` from the edge data. Establishes a default direction (e.g., from source handle to target handle) for passive components.
  - **Selects Reference Node:** Chooses `n0` as the reference ground node.
  - **Finds Spanning Tree:** Implements a Breadth-First Search (BFS) or Depth-First Search (DFS) starting from the reference node to build a spanning tree. Edges traversed are `spanningTreeBranchIds`; remaining edges are `linkBranchIds`.
  - Returns the complete `AnalysisGraph` object.

#### **`validation.ts`**

- **`validateGraph(graph: AnalysisGraph): { isSolvable: boolean; error: string | null }`**:
  - Checks if the graph is fully connected (all nodes are reachable from the reference node).
  - Ensures there is at least one voltage or current source.
  - Ensures there are no loops consisting only of voltage sources or short circuits.
  - Ensures there are no cut-sets consisting only of current sources.

#### **`loopAnalysis.ts`** (and `nodalAnalysis.ts`)

- **`calculateTieSetMatrix(graph: AnalysisGraph): Matrix`**: Forms the `B` matrix. For each link, traces the fundamental loop through the spanning tree and populates a row with +1, -1, or 0.
- **`createBranchImpedanceMatrix(graph: AnalysisGraph): Matrix`**: Creates a diagonal matrix `ZB` where `ZB[i][i]` is the impedance of branch `i`. Voltage sources have 0 impedance.
- **`solveLoopEquations(B: Matrix, ZB: Matrix, EB: Matrix): { IL: Matrix, JB: Matrix, VB: Matrix }`**:
  - Performs the calculations from the PDF strictly:
    1.  `Z_loop = B * ZB * B^T`
    2.  `E_loop = B * EB`
    3.  `IL = solve(Z_loop, E_loop)` using `math.lusolve(Z_loop, E_loop)`.
    4.  `JB = B^T * IL`
    5.  `VB = ZB * JB - EB`
  - Wraps `math.lusolve` in a `try...catch` to handle singular matrix errors.
  - Returns all key results.

#### **`reportGenerator.ts`**

- **`matrixToLatex(matrix: Matrix): string`**: A helper function that converts a `math.js` matrix into a LaTeX `pmatrix` string for KaTeX rendering.
- **`generateMarkdownReport(result: CalculationResult, graph: AnalysisGraph): string`**:
  - This function is a meticulous string builder.
  - It creates sections for each step of the analysis (e.g., "Loop Analysis").
  - It presents each matrix with a heading and its LaTeX representation. `## Tie-Set Matrix (B)\n\n $$ B = ${matrixToLatex(result.tieSetMatrix)} $$`
  - It shows the core equations being solved: `$$ Z_{loop} I_L = E_{loop} $$`
  - It displays the final results (branch currents and voltages) in a formatted table using Markdown table syntax.

---

### **Step 3: The Context Providers (`analysis/contexts/`)**

This is the React layer that orchestrates the calls to the utility functions.

#### **`AnalysisProvider.tsx` (Layer 1)**

```tsx
const AnalysisContext = createContext<AnalysisState | undefined>(undefined);

export const AnalysisProvider = ({ circuit, children }) => {
  const [state, setState] = useState<AnalysisState>({
    /* initial state */
  });

  useEffect(() => {
    if (!circuit) return;

    try {
      // 1. Transform the raw model into a pure graph
      const graph = createAnalysisGraph(circuit);

      // 2. Validate the graph for solvability
      const { isSolvable, error } = validateGraph(graph);

      setState({
        analysisGraph: graph,
        isValid: true,
        isSolvable,
        error,
      });
    } catch (e) {
      setState({
        analysisGraph: null,
        isValid: false,
        isSolvable: false,
        error: e.message,
      });
    }
  }, [circuit]); // This effect re-runs ONLY when the circuit structure changes

  return <AnalysisContext.Provider value={state}>{children}</AnalysisContext.Provider>;
};
```

#### **`MatrixCalculationProvider.tsx` (Layer 2)**

```tsx
const MatrixCalculationContext = createContext<MatrixCalculationState | undefined>(undefined);

export const MatrixCalculationProvider = ({ children }) => {
  const { analysisGraph, isSolvable, error: validationError } = useAnalysis(); // Consumes from Layer 1
  const [state, setState] = useState<MatrixCalculationState>({ /* ... */ });

  useEffect(() => {
    if (!isSolvable || !analysisGraph) {
      setState({ result: null, isCalculating: false, error: validationError });
      return;
    }

    setState({ ...state, isCalculating: true });

    // Asynchronous wrapper to prevent UI freeze on large circuits
    const calculate = async () => {
      try {
        // --- This is where you choose the method or run both ---
        const B = calculateTieSetMatrix(analysisGraph);
        const ZB = createBranchImpedanceMatrix(analysisGraph);
        const EB = /* create source vector from graph */;
        const loopResults = solveLoopEquations(B, ZB, EB);

        // ... call nodal analysis functions as well ...

        setState({
          result: { ...loopResults, /* ...nodal results */ },
          isCalculating: false,
          error: null,
        });
      } catch (e) {
        setState({ result: null, isCalculating: false, error: e.message });
      }
    };
    calculate();
  }, [analysisGraph, isSolvable, validationError]);

  return (
    <MatrixCalculationContext.Provider value={state}>
      {children}
    </MatrixCalculationContext.Provider>
  );
};
```

#### **`PresentationProvider.tsx` (Layer 3)** and the final UI component are structured similarly, consuming the state from the layer above and calling the `reportGenerator` utility.

### **How to Use It**

Your main `AnalysisPane.tsx` will be clean and declarative:

```tsx
// In some parent component
<AnalysisProvider circuit={activeCircuit}>
  <MatrixCalculationProvider>
    <PresentationProvider>
      <AnalysisPane />
    </PresentationProvider>
  </MatrixCalculationProvider>
</AnalysisProvider>;

// In AnalysisPane.tsx
import { useAnalysis, useMatrixCalculations, usePresentation } from "../analysis/hooks";
import { ReactMarkdown } from "react-markdown";
// ... KaTeX plugins ...

export const AnalysisPane = () => {
  const { error: validationError } = useAnalysis();
  const { isCalculating, error: mathError } = useMatrixCalculations();
  const { markdownOutput, isGenerating } = usePresentation();

  if (validationError) return <ErrorMessage message={validationError} />;
  if (isCalculating || isGenerating) return <Spinner />;
  if (mathError) return <ErrorMessage message={mathError} />;

  return (
    <div className="report-container">
      <ReactMarkdown /* ... plugins ... */>{markdownOutput}</ReactMarkdown>
    </div>
  );
};
```
